// Generated by CoffeeScript 1.6.3
(function() {
  var Local, Log, Peer, Remote, local, logger, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Log = (function() {
    function Log() {}

    Log.prototype.log = function(thing) {
      return console.log(thing);
    };

    Log.prototype.trace = function(text) {
      return console.log((performance.now() / 1000).toFixed(3) + ": " + text);
    };

    Log.prototype.error = function(text) {
      return console.error((performance.now() / 1000).toFixed(3) + ": " + text);
    };

    return Log;

  })();

  Peer = (function() {
    function Peer(name, peers, connections) {
      this.name = name;
      this.peers = peers != null ? peers : [];
      this.connections = connections != null ? connections : [];
    }

    return Peer;

  })();

  Local = (function(_super) {
    __extends(Local, _super);

    function Local(name, peers) {
      if (peers == null) {
        peers = [];
      }
      Local.__super__.constructor.call(this, name, peers);
    }

    Local.prototype.connect = function(peer) {
      this.peers.push(peer);
      return this.connections.push(new Connection(this, peer));
    };

    Local.prototype.send = function(message) {
      return this.connection.send(message);
    };

    return Local;

  })(Peer);

  Remote = (function(_super) {
    __extends(Remote, _super);

    function Remote() {
      _ref = Remote.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    return Remote;

  })(Peer);

  /*
  class Connection
      constructor: (@name, @channelName) ->
          servers = null;
          this.rtcpc = new RTCPeerConnection(servers, {
              optional: [{RtpDataChannels: true}]
          });
          this.rtcpc.onconnection = this.onConnection
          this.rtcpc.onicecandidate = this.onIceCandidate
          this.rtcpc.onopen = this.onOpen
          this.rtcpc.onClose = this.onClose
  
      send: (message) ->
          if (this.channel not null)
              this.channel.send(message)
          else
              logger.error('Could not send message, no channel set on connection.')
  
      onConnection: ->
          logger.trace('Connection.onConnection')
          this.channel = new DataChannel(this.channelName, this.rtcpc)
  
      onIceCandidate: (event) ->
          logger.trace('Connection.onIceCandidate')
  
      onMessage: (event) ->
          logger.trace('Connection.onMessage')
          logger.log(event)
  
      onOpen: ->
          logger.trace('Connection.onOpen')
  
      onClose: ->
          logger.trace('Connection.onClose')
  
  
  class LocalConnection extends Connection
      onOpen: ->
          super
          this.send("Hello Remote!")
          
  
  class RemoteConnection extends Connection
      onOpen: ->
          super
          this.send("Hello Local!")
  
  class Channel
      constructor: (@name) ->
  
  class DataChannel extends Channel
      constructor: (@name, @connection) ->
          super @name
          try
              this.channel = this.connection.createDataChannel(this.name, {
                  reliable: false
              });
  
          catch error
              logger.error('Failed to create data connection with exception: ' + error)
  */


  logger = new Log;

  local = new Local;

  local.connect(new Remote('remote1'));

}).call(this);
